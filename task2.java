package Main;

import java.util.*;
import java.math.BigInteger;

public class eos6_task2 {
    Random ran = new Random();

    /**
     * Main method of initializing
     * Goldwasser Micali encryption system
     */
    public void goldwasserMicali() {
        // Generate two v/2bits "large primes" p and q
        Scanner v_input = new Scanner(System.in);
        System.out.println("Please enter the security parameter 'nu': ");
        int v = v_input.nextInt();
        System.out.println("----------------------");

        // Searches all available factors of the security parameter.
        System.out.println("Setup:");
        ArrayList<Integer> factorsOfN = new ArrayList<>();
        factorsOfN = factors(v, factorsOfN);

        // Finds random prime number, which then
        // which then can be used to find a multiple
        // that can be multiplied to N
        int p = findPrimeNumbers(factorsOfN);
        System.out.println("The first prime generated by the Setup algorithm is p = " + p);

        int q = 0;
        // Remove any duplicate values that matches p
        for(int i = 0; i < factorsOfN.size(); i++) {
            if(p == factorsOfN.get(i)) {
                factorsOfN.remove(i);
            }
        }
        for(int i = 0; i < factorsOfN.size(); i++) {
            q = factorsOfN.get(i);
            break;
        }

        // Calculating N to ensure that both p and q equate to our security parameter.
        System.out.println("The second prime generated by the Setup algorithm is q = " + q);
        int N = p * q;
        System.out.println("The integer N = pq = " + N);

        // Legendre Calculation
        int yp = LegrendreCalculation(p);
        int yq = LegrendreCalculation(q);

        // Chinese Remainder theorem
        int y = chineseRemainderTheorem(yp, yq, p, q);

        System.out.println("The public key y = " + y);
        System.out.println("----------------------");

        // Directs to option function for user to select
        // either decryption or decryption
        option(factorsOfN, p, q, y, N);
    }

    /**
     * Searches all divisors from a provided
     * security parameter.
     *
     * @param v
     * @param factors
     * @return
     */
    public ArrayList<Integer> factors(int v, ArrayList<Integer> factors) {
        int k = (int) Math.floor(Math.sqrt(v));
        System.out.println("Searching for divisors between 2 and " + k);
        for(int i = 2; i <= v; i++) {
            // Add a divisor that is common to divide the given security
            // parameter
            while(v % i == 0) {
                factors.add(i);
                v /= i;
            }
        }

        // Check for any duplicate numbers from the set
        int duplicateNumber = 0;
        for(int i = 0; i < factors.size(); i++) {
            if(factors.get(i) == duplicateNumber) {
                factors.remove(i);
            }
            duplicateNumber = factors.get(i);
        }

        return factors;
    }

    /**
     * Returns a random factor for a given
     * prime number for P.
     *
     * @param factors
     * @return
     */
    public int findPrimeNumbers(ArrayList<Integer> factors) {
        // * Completed - Have a review before moving to next task
        int randomPrime = ran.nextInt(factors.size());
        int prime = factors.get(randomPrime);
        return prime;
    }

    /**
     * Extended Eucledian Algorithm that
     * returns if the following value
     * is mutually prime.
     *
     * @param e
     * @param M
     * @return
     */
    public static int extendedEucledianAlgorithm(int e, int M) {
        // * Works perfectly fine.
        if(e == 0) {
            if(M == 1)  {
                return M;
            }
            return e;
        }

        return extendedEucledianAlgorithm(M % e, e);
    }

    /**
     * Calculates the Chinese Remainder Theorem
     * that requires both prime numbers
     * to solve every pair of congruences.
     *
     * @param yp
     * @param yq
     * @param p
     * @param q
     * @return
     */
    public static int chineseRemainderTheorem(int yp, int yq, int p, int q) {
        int unique_solution = extendedEucledianAlgorithm(p, q);
        if(unique_solution != 1) {
           throw new RuntimeException("They are not relatively prime");
        }

        BigInteger a, b, M, N;

        a = BigInteger.valueOf(yp);
        M = BigInteger.valueOf(p);
        b = BigInteger.valueOf(yq);
        N = BigInteger.valueOf(q);

        BigInteger T =  M.modInverse(N);
        BigInteger u = (b.subtract(a)).multiply(T).mod(N);
        BigInteger x = a.add(u).multiply(M);

        BigInteger v = BigInteger.valueOf(x.intValue());
        BigInteger equationSubstitution = a.add(b.multiply(v));

        BigInteger example1 = equationSubstitution.mod(a);
        BigInteger example2 = equationSubstitution.mod(b);

        // Check for comparison.
        if(!(equationSubstitution.mod(a).equals(example1) && equationSubstitution.mod(b).equals(example2))) {
            throw new RuntimeException("Not equal.");
        }

        return x.intValue(); // check if that even belongs to the fourth quadrant (Jn / QRn)
    }

    /**
     * Uses the algorithm correctness of Legendre
     * to calculate whether the given value is
     * either a quadratic residue or quadratic non-residue.
     * If it is quadratic residue, perform Legendre Calculation
     * with random element below P.
     *
     * @param p
     * @return result if it is Quadratic Non-Residue,
     */
    public static int LegrendreCalculation(int p) {
        // Using the Algorithm Correctness of Legrendre Calculation
        BigInteger P, ONE, P_1, TWO, B, B_Squared, Result;
        Random ran = new Random();
        int b = ran.nextInt(p); // choose an element from the set of p from 1 to p - 1
        P = BigInteger.valueOf(p);
        B = BigInteger.valueOf(b);
        ONE = new BigInteger("1");
        TWO = new BigInteger("2");
        P_1 = (P.subtract(ONE)).divide(TWO); // (p -1) / 2
        B_Squared = B.pow(P_1.intValue()); // a^(p - 1) / 2 mod P
        Result = BigInteger.valueOf(B_Squared.mod(P).intValue());

        if(Result.intValue() == (P.intValue() - 1)) { // check if result equtes to p - 1.
            return Result.intValue(); // It is -1, therefore, it is a quadratic non-residue
        }
        if(Result.intValue() == 0) {
            LegrendreCalculation(p); // Check if it is equal
        }

        ArrayList<Integer> QRp = new ArrayList<Integer>();
        BigInteger base, exponent, mod, residue;
        for(int i = 1; i < p; i++) {
            base = BigInteger.valueOf(i);
            exponent = BigInteger.valueOf(2);
            mod = BigInteger.valueOf(p);
            residue = base.modPow(exponent, mod);
            QRp.add(residue.intValue());
        }

        QRp.sort(Comparator.naturalOrder()); // Changed the order of the results

        if(QRp.contains(Result.intValue())) {
            LegrendreCalculation(p); // quadratic residue
        }

        return Result.intValue();
    }

    /**
     * Uses the algorithm correctness of Legendre
     * to calculate whether the given value is
     * either a quadratic residue or quadratic non-residue.
     *
     * @param c, p
     * @return 1 if it is Quadratic Non-Residue,
     * 0 if it is a quadratic residue
     */
    public static int LegendreDecryptionCalculation(int c, int p) {
        // Using the Algorithm Correctness of Legrendre Calculation
        BigInteger C, ONE, P_1, TWO, P, C_Squared, Result;

        C = BigInteger.valueOf(c);
        P = BigInteger.valueOf(p);

        ONE = new BigInteger("1");
        TWO = new BigInteger("2");
        P_1 = (P.subtract(ONE)).divide(TWO); // (p -1) / 2
        C_Squared = C.pow(P_1.intValue()); // a^(p - 1) / 2 mod P

        Result = BigInteger.valueOf(C_Squared.mod(P).intValue());

        if(Result.intValue() == (P.intValue() - 1)) { // check if result equates to p - 1.
            return -1; // Quadratic Non-Residue
        }
        if(Result.intValue() == 0) {
            return 0; // Neither of those
        }

        ArrayList<Integer> QRp = new ArrayList<Integer>();
        BigInteger base, exponent, mod, residue;
        for(int i = 1; i < p; i++) {
            base = BigInteger.valueOf(i);
            exponent = BigInteger.valueOf(2);
            mod = BigInteger.valueOf(p);
            residue = base.modPow(exponent, mod);
            QRp.add(residue.intValue());
        }

        QRp.sort(Comparator.naturalOrder()); // Sort the order of the results

        if(QRp.contains(Result.intValue())) {
            return 1; // Quadratic residue
        }

        return -2; // return unknown result if it does not meet neither of those requirements
    }

    /**
     * Calculates the Jacobian Calculation to check whether
     * the following value of a is either quadratic residue
     * or quadratic non-residue.
     *
     * @param N
     * @param a
     * @param p
     * @param q
     * @return
     */
    public static int JacobianCalculation(int N, int a, int p, int q) {
        // (b/N) = (b/p)(b/q) = either 0 or 1
        BigInteger N_, P, Q, ONE, P_1, Q_1, N_1, TWO, B, B_, B_P, B_Q, P_BIT, Q_BIT, BIT;

        B = BigInteger.valueOf(a);
        N_ = BigInteger.valueOf(N);

        P = BigInteger.valueOf(p);
        Q = BigInteger.valueOf(q);
        ONE = new BigInteger("1");
        TWO = new BigInteger("2");
        P_1 = (P.subtract(ONE)).divide(TWO); // (p -1) / 2
        Q_1 = (Q.subtract(ONE)).divide(TWO); // (p -1) / 2
        B_P = B.pow(P_1.intValue()); // a^(p - 1) / 2 mod P
        B_Q = B.pow(Q_1.intValue()); // a^(q - 1) / 2 mod P

        P_BIT = BigInteger.valueOf(B_P.mod(P).intValue());
        int p_bit = jacobiEvaluation(P_BIT, N_, p);

        Q_BIT = BigInteger.valueOf(B_Q.mod(Q).intValue());
        int q_bit = jacobiEvaluation(Q_BIT, N_, q);

        int result = p_bit * q_bit;
        return result;
    }

    /**
     * Passes the value for further Jacobian Calculation
     * to return result if the following value is
     * either quadratic residue or quadratic non-residue.
     *
     * @param P_1
     * @param P
     * @param a
     * @return
     */
    public static int jacobiEvaluation(BigInteger P_1, BigInteger P, int a) {
        if(P_1.intValue() == (P.intValue() - 1)) {
            return -1; // (p - 1) is -1, therefore, it is a quadratic non-residue.
        }
        if(P_1.intValue() == 0) {
            return 1; // 0
        }

        ArrayList<Integer> QRp = new ArrayList<Integer>();
        BigInteger base, exponent, mod, residue;
        for(int i = 1; i < a; i++) {
            base = BigInteger.valueOf(i);
            exponent = BigInteger.valueOf(2);
            mod = BigInteger.valueOf(a);
            residue = base.modPow(exponent, mod);
            QRp.add(residue.intValue());
        }

        QRp.sort(Comparator.naturalOrder());

        if(QRp.contains(P_1.intValue())) {
            return 0;
        }

        return -1; // return -1 if it is neither quadratic residue or quadratic non-residue
    }

    /**
     * Squares a random X value underneath N, from a given plaintext if a
     * message bit equates to 0.
     *
     * @param CipherText
     * @param N
     */
    public static void encryptingX(ArrayList<String> CipherText, int N) {
        Random ran = new Random();
        int randomNumber = ran.nextInt(N);
        int x = extendedEucledianAlgorithm(randomNumber, N);
        if(x == 1) {
            BigInteger RN, TWO, SQ, N_MOD, RESULT;
            RN = BigInteger.valueOf(randomNumber);
            TWO = new BigInteger("2");
            SQ = RN.pow(TWO.intValue());
            N_MOD = BigInteger.valueOf(N);
            RESULT = BigInteger.valueOf((SQ.mod(N_MOD)).intValue());
            CipherText.add(String.valueOf(RESULT.intValue()));
        }
        else {
            encryptingX(CipherText, N);
        }
    }

    /**
     * Squares a random value of X underneath N and multiplies by y
     * if a message bit equates to 1.
     *
     * @param CipherText
     * @param N
     * @param y
     */
    public static void encryptingXY(ArrayList<String> CipherText, int N, int y) {
        Random ran = new Random();
        int randomNumber = ran.nextInt(N);
        int x = extendedEucledianAlgorithm(randomNumber, N);
        if(x == 1) {
            BigInteger RN, TWO, SQ, Y, CALCULATION, N_MOD, RESULT;
            RN = BigInteger.valueOf(randomNumber);
            TWO = new BigInteger("2");
            SQ = RN.pow(TWO.intValue());
            Y = BigInteger.valueOf(y);
            CALCULATION = Y.multiply(SQ);
            N_MOD = BigInteger.valueOf(N);
            RESULT = BigInteger.valueOf((CALCULATION.mod(N_MOD)).intValue());
            CipherText.add(String.valueOf(RESULT.intValue()));
        }
        else {
            encryptingXY(CipherText, N, y);
        }
    }

    /**
     * Option section that provides choice
     * for encryption or decryption, that can
     * be only selected using integers
     *
     * @param factorsOfN
     * @param p
     * @param q
     * @param y
     * @param N
     */
    public void option(ArrayList<Integer> factorsOfN, int p, int q, int y, int N) {
        Scanner input = new Scanner(System.in);
        System.out.println("Please enter an option");
        System.out.println("1 to Encrypt");
        System.out.println("2 to Decrypt");
        System.out.println("Any other number to quit");
        int option = input.nextInt();
        System.out.println("Your option: " + option);
        System.out.println("----------------------");

        while(true) {
            switch(option) {
                case 1:
                    encryption(factorsOfN, N, y, p, q);
                    break;
                case 2:
                    decryption(factorsOfN, N, p, q, y);
                    break;
                default: // perform this action with only numbers
                    System.out.println("Quitting application...");
                    break;
            }
            break;
        }
    }

    /**
     * Extracts plaintext that is either pure
     * integer or characters, which extracts
     * ASCII values for a further process of encryption.
     *
     * @param factorsOfN
     * @param plaintext
     * @param N
     * @param m
     * @param y
     * @param p
     * @param q
     * @return
     */
    public static ArrayList<Integer> extractingPlaintext(ArrayList<Integer> factorsOfN, String plaintext, int N, int m, int y, int p, int q) {
        char[] plaintextCheck = plaintext.toCharArray();

        // Check if any of the following plaintext contains
        // a letter, digit or other unknown characters
        int isLetter = 0;
        int isDigit = 0;
        int unknown = 0;
        for(int i = 0; i < plaintextCheck.length; i++){
            if(Character.isDigit(plaintextCheck[i])) {
                isDigit++;
            }
            if(Character.isLetter(plaintextCheck[i])) {
                isLetter++;
            }
            if(!Character.isLetterOrDigit(plaintextCheck[i])) {
                unknown++;
            }
        }

        ArrayList<Integer> unicodeInt = new ArrayList<Integer>();
        if((isLetter > 0 && isDigit > 0) || (unknown > 0)) {
            // Calculate the amount of whitespaces and commas
            // the following plaintext contains in terms of characters.
            int whitespace = 0;
            int comma = 0;
            for(int i = 0; i < plaintextCheck.length; i++) {
                if(Character.isWhitespace(plaintextCheck[i])) {
                    whitespace++;
                }
                String cipherCheckString = String.valueOf(plaintextCheck[i]);
                if(cipherCheckString.contains(",")) {
                    comma++;
                }
            }
            if(whitespace > 0 || comma > 0) {
                for(int i = 0; i < plaintextCheck.length; i++) {
                    String cipherCheckString = String.valueOf(plaintextCheck[i]);

                    // Skip to another i if a specific character detects a whitespace or comma
                    if(Character.isWhitespace(plaintextCheck[i]) || cipherCheckString.contains(",")) {
                        break;
                    }

                    ArrayList<String> cipherArrayNumber = new ArrayList<String>();
                    cipherArrayNumber.add(String.valueOf(plaintextCheck[i]));

                    String stringCipherBuilder = new String();
                    int index_skip = 0;
                    for(int l = i; l < plaintextCheck.length; l++) {
                        String SecondCipherCheckString = String.valueOf(plaintextCheck[i]);
                        if(Character.isWhitespace(plaintextCheck[l]) || SecondCipherCheckString.contains(",")) {
                            break;
                        }
                        stringCipherBuilder += plaintextCheck[l];

                        // Check if it is a letter so it can be converted into Unicode
                        if(isLetter > isDigit) {
                            int unicode = plaintextCheck[l];
                            unicodeInt.add(unicode);
                        }
                        index_skip++;
                    }

                    // Check if it is a digit so it can be parsed to process values
                    if(isDigit > isLetter) {
                        int unicode = Integer.parseInt(stringCipherBuilder);
                        unicodeInt.add(unicode);
                    }
                    i += index_skip;
                }
                return unicodeInt;
            }
        }
        // Check if it contains only letters, without digits, whitespaces, commas
        // or other unknown characters
        if(isLetter > 0 && isDigit == 0) {
            ArrayList unicodeChars = new ArrayList<String>();
            for(int i = 0; i < plaintext.length(); i++) {
                unicodeChars.add(plaintext.charAt(i));
            }

            for(int i = 0; i < unicodeChars.size(); i++) {
                int unicode = plaintext.charAt(i);
                unicodeInt.add(unicode);
            }
            return unicodeInt;
        }

        // Check if it contains only digits, without letters, whitespaces, commas
        // or other unknown characters
        if(isLetter == 0 && isDigit > 0) { // It's all good man
            for(int i = 0; i < plaintextCheck.length; i++) {
                unicodeInt.add(Integer.parseInt(String.valueOf(plaintextCheck[i])));
            }
            return unicodeInt;
        }
        return unicodeInt;
    }

    /**
     * Encrypts the given plaintext, which is extracted
     * to be converted to random values if a given value
     * from a specified plaintext is quadratic residue or
     * quadratic non-residue
     *
     * @param factorsOfN
     * @param N
     * @param y
     * @param p
     * @param q
     * @return
     */
    public static String encryption(ArrayList<Integer> factorsOfN, int N, int y, int p, int q) {
        System.out.println("Your message space is set: {0,  1}");
        Scanner input = new Scanner(System.in);
        System.out.println("Please enter a number from this set: ");
        int numberInput = input.nextInt();

        // Ensures that the following selected number for
        // the message bit does not exceed
        if(numberInput > 1) {
            System.out.println("The number input for your message space is above 1.");
            System.out.println("Pick the number input of the message space between either 0 or 1");
            encryption(factorsOfN, N, y, p, q);
        }
        boolean print1bit = false;
        boolean print0bit = false;
        if(numberInput == 1) {
           print1bit = true;
        }
        if(numberInput == 0) {
            print0bit = true;
        }

        // When writing the ciphertext, make sure it contains a whitespace or comma in between
        // to check through a loop for the text to be transformed into message bits
        // For example: If you're inputting values, it should be typed like this (without quotation marks):
        // "103, 104, 108 " OR "103 104 108 "
        // Same applies for plaintext (without quotation marks):
        // Example 1: "hello ", "this is a message "
        Scanner cipherinput = new Scanner(System.in);
        System.out.println("The ciphertext for your message: ");
        String cipher = cipherinput.nextLine();

        // Extract values from the following plaintext to be processed.
        ArrayList<Integer> unicodeInt = extractingPlaintext(factorsOfN, cipher, N, numberInput, y, p, q);

        // Check if the following message bit is {0} or {1}
        ArrayList<String> CipherText = new ArrayList<String>();
        for(int i = 0; i < unicodeInt.size(); i++) {
            int bit = JacobianCalculation(N, unicodeInt.get(i), p, q);
            if(bit == 1) {
                if(!print0bit && print1bit) {
                    encryptingX(CipherText, N);
                }
            }
            else if(bit == 0) {
                if(print0bit || print1bit) {
                    encryptingXY(CipherText, N, y);
                }
            }
        }

        System.out.println("The ciphertext for your message " + cipher + " is ");
        System.out.println(" ");
        for(int i = 0; i < CipherText.size(); i++) {
            System.out.print(CipherText.get(i) + " ");
        }

        System.out.println(" ");
        System.out.println("----------------------");
        System.out.println(" ");

        return cipher;
    }

    /**
     * Extracts a ciphertext that was encrypted
     * that accepts integers.
     *
     * @param factorsOfN
     * @param plaintext
     * @param N
     * @param m
     * @param y
     * @param p
     * @param q
     * @return
     */
    public static ArrayList<BigInteger> extractingCiphertext(ArrayList<Integer> factorsOfN, String plaintext, int N, int m, int y, int p, int q) {
        char[] cipherCheck = plaintext.toCharArray();
        int isLetter = 0;
        int isDigit = 0;
        int unknown = 0;
        for(int i = 0; i < cipherCheck.length; i++){
            if(Character.isDigit(cipherCheck[i])) { isDigit++; }
            if(Character.isLetter(cipherCheck[i])) { isLetter++; }
            if(!Character.isLetterOrDigit(cipherCheck[i])) { unknown++; }
        }

        ArrayList<BigInteger> unicodeInt = new ArrayList<BigInteger>();
        if((isLetter > 0 && isDigit > 0) || (unknown > 0)) {
            int whitespace = 0;
            int comma = 0;
            for(int i = 0; i < cipherCheck.length; i++) {
                if(Character.isWhitespace(cipherCheck[i])) {
                    whitespace++;
                }
                String cipherCheckString = String.valueOf(cipherCheck[i]);
                if(cipherCheckString.contains(",")) {
                    comma++;
                }
            }
            if(whitespace > 0 || comma > 0) {
                for(int i = 0; i < cipherCheck.length; i++) {
                    String cipherCheckString = String.valueOf(cipherCheck[i]);
                    if(Character.isWhitespace(cipherCheck[i]) || cipherCheckString.contains(",")) {
                        break;
                    }

                    ArrayList<String> cipherArrayNumber = new ArrayList<String>();
                    cipherArrayNumber.add(String.valueOf(cipherCheck[i]));

                    String stringCipherBuilder = new String();
                    int index_skip = 0;
                    for(int l = i; l < cipherCheck.length; l++) {
                        String SecondCipherCheckString = String.valueOf(cipherCheck[i]);
                        if(Character.isWhitespace(cipherCheck[l]) || SecondCipherCheckString.contains(",")) {
                            break;
                        }
                        stringCipherBuilder += cipherCheck[l];
                        index_skip++;
                    }

                    BigInteger stringCipherBigInteger = new BigInteger(stringCipherBuilder);
                    unicodeInt.add(stringCipherBigInteger);

                    i += index_skip;
                }
                return unicodeInt;
            }
        }
        if(isLetter > 0 && isDigit == 0) {
            throw new RuntimeException("The ciphertext should only contain values ");
        }
        return unicodeInt;
    }

    /**
     * Decrypts the provided ciphertext by evaluating
     * and calculating whether each value in the provided
     * ciphertext is quadratic residue or quadratic non-residue.
     * After calculation, will be converted into message bits
     * of 0 or 1.
     *
     * @param factorsOfN
     * @param N
     * @param p
     * @param q
     * @param y
     * @return
     */
    public static String decryption(ArrayList<Integer> factorsOfN, int N, int p, int q, int y) {
        System.out.println("Your ciphertext space is set J_" + N);

        Scanner input = new Scanner(System.in);
        System.out.println("Please enter a number from this set: ");
        int numberInput = input.nextInt();

        // Replaces the following N
        // if numberInput is provided
        // Below N.
        if(numberInput > N) {
            System.out.println("The number of your input is not part of the set");
            decryption(factorsOfN, N, p, q, y);
        }
        if(numberInput != N) {
            N = numberInput; // P and Q primes stay the same.
        }

        Scanner decryptInput = new Scanner(System.in);
        System.out.println("The plaintext for your message: ");
        String cipherString = decryptInput.nextLine();

        // Extracts the following cipherText that will be converted into message bits
        ArrayList<BigInteger> unicodeInt = extractingCiphertext(factorsOfN, cipherString, N, numberInput, y, p, q);

        // Perform legendre to check if the following bit is {0} or {1}
        ArrayList<Integer> decryptedMessage = new ArrayList<Integer>();
        for(int i = 0; i < unicodeInt.size(); i++) {
            Integer unicodeToInt = Integer.parseInt(String.valueOf(unicodeInt.get(i)));
            int bit = LegendreDecryptionCalculation(unicodeToInt, p);
            if(bit == 1) {
                bit = LegendreDecryptionCalculation(unicodeToInt, q);
                if(bit == 1) {
                    decryptedMessage.add(0);
                }
            }
            if(bit == -1) {
                decryptedMessage.add(0);
            }
        }

        System.out.println(" ");
        System.out.println("The plaintext for your ciphertext " + cipherString + " is ");
        for(int i = 0; i < decryptedMessage.size(); i++) {
            System.out.print(decryptedMessage.get(i) + " ");
        }

        System.out.println(" ");
        System.out.println("----------------------");
        System.out.println(" ");

        return cipherString;
    }
}
