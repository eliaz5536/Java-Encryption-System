package Main;

import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;
import java.util.Random;
import java.math.BigInteger;

/**
 * RSA Encryption System
 */
public class eos6_task1 {
    Random ran = new Random();

    /**
     * Main method of starting
     */
    public void naiveRSA() {
        // Security Parameter
        Scanner v_input = new Scanner(System.in);
        System.out.println("Please enter the security parameter 'nu': ");
        int v = v_input.nextInt();
        System.out.println("----------------------");

        System.out.println("Setup:");
        // Finding two prime numbers
        ArrayList<Integer> factorsOfN = new ArrayList<>();
        factorsOfN = factors(v, factorsOfN);

        // Searching prime numbers for P.
        int p = findPrimeNumbers(factorsOfN);
        System.out.println("The first prime generated by the Setup algorithm is p = " + p);

        // Loops through all factors from arraylist that is a multiple,
        // which equates to N
        int q = 0;
        for(int i = 0; i < factorsOfN.size(); i++) {
            if(p == factorsOfN.get(i)) {
                factorsOfN.remove(i);
            }
        }
        for(int i = 0; i < factorsOfN.size(); i++) {
            q = factorsOfN.get(i);
            break;
        }

        System.out.println("The second prime generated by the Setup algorithm is q = " + q);
        int N = p * q;
        System.out.println("The integer N = pq = " + N);
        // Calculates the Phi of N.
        int M = phiOfN(N, p, q);

        /**
         * Searches the encryption exponent
         * by finding random number under N
         * using Extended Eucledian Algorithm
         * that is mutually prime
         */
        int e;
        while(true)  {
            e = ran.nextInt(N);
            int gcd = extendedEucledianAlgorithm(e, M);
            if(gcd == 1) {
                break;
            }
        }
        System.out.println("The encryption exponent is e = " + e);

        int d;
        while(true) {
           d = ran.nextInt(N);
           int findD = findIntegerD(d, e, N, M);
           if(findD == 1) {
               break;
           }
        }
        System.out.println("The decryption exponent is d = " + d);
        System.out.println("----------------------");

        // Initializes option section
        option(e, d, N, M);
    }

    /**
     * Searches all divisors from a provided
     * security parameter
     *
     * @param v
     * @param factors
     * @return
     */
    public ArrayList<Integer> factors(int v, ArrayList<Integer> factors) {
        // Floor and square root the given security parameter to find the highest common divisor
        int k = (int) Math.floor(Math.sqrt(v));
        System.out.println("Searching for divisors between 2 and " + k);

        // Searches through all divisors
        // from a security parameter
        for(int i = 2; i <= v; i++) {
           while(v % i == 0) {
              factors.add(i);
              v /= i;
           }
        }

        // Check for any duplicate numbers from the set
        int duplicateNumber = 0;
        for(int i = 0; i < factors.size(); i++) {
           if(factors.get(i) == duplicateNumber) {
              factors.remove(i);
           }
           duplicateNumber = factors.get(i);
        }

        return factors;
    }

    /**
     * Returns a random factor for a given
     * prime number for P.
     *
     * @param factors
     * @return
     */
    public int findPrimeNumbers(ArrayList<Integer> factors) {
        // * Completed - Have a review before moving to next task
        int randomPrime = ran.nextInt(factors.size());
        int prime = factors.get(randomPrime);
        return prime;
    }

    /**
     * Returns the calculation of the
     * phi of N.
     *
     * @param N
     * @param p
     * @param q
     * @return
     */
    public int phiOfN(int N, int p, int q) {
        int total = (p - 1) * (q - 1);
        return total;
    }

    /**
     * Calculates the integer D
     * to check if it is mutually prime
     * @param d
     * @param e
     * @param N
     * @param M
     * @return
     */
    public static int findIntegerD(int d, int e, int N, int M) {
        int total = (d * e) % M;
        return total;
    }

    /**
     * Extended Eucledian Algorithm that
     * returns if the following value
     * is mutually prime.
     * @param e
     * @param M
     * @return
     */
    public static int extendedEucledianAlgorithm(int e, int M) {
        if(e == 0) {
           if(M == 1)  {
            return M;
           }
           return e;
        }

        return extendedEucledianAlgorithm(M % e, e);
    }

    /**
     * Option section that provides choice
     * for encryption or decryption, that can
     * be only selected using integers
     * @param e
     * @param d
     * @param N
     * @param M
     */
    public void option(int e, int d, int N, int M) {
        Scanner input = new Scanner(System.in);
        System.out.println("Please enter an option");
        System.out.println("1 to Encrypt");
        System.out.println("2 to Decrypt");
        System.out.println("Any other number to quit");
        int option = input.nextInt();
        System.out.println("Your option: " + option);
        System.out.println("----------------------");

        while(true) {
            switch(option) {
                case 1:
                    encryption(N, e);
                    break;
                case 2:
                    decryption(N, e, d);
                    break;
                default: // perform this action with only numbers
                    System.out.println("Quitting application...");
                    break;
            }
            break;
        }
    }

    /**
     * Extracts plaintext that is either pure
     * integer or characters, which extracts
     * ASCII values for a further process of
     * encryption.
     * @param plaintext
     * @param N
     * @param m
     * @param e
     * @return
     */
    public static ArrayList<Integer> extractingPlaintext(String plaintext, int N, int m, int e) {
        char[] plaintextCheck = plaintext.toCharArray();

        // Check if any of the following plaintext contains
        // a letter, digit or other unknown characters
        int isLetter = 0;
        int isDigit = 0;
        int unknown = 0;
        for(int i = 0; i < plaintextCheck.length; i++){
            if(Character.isDigit(plaintextCheck[i])) {
                isDigit++;
            }
            if(Character.isLetter(plaintextCheck[i])) {
                isLetter++;
            }
            if(!Character.isLetterOrDigit(plaintextCheck[i])) {
                unknown++;
            }
        }

        ArrayList<Integer> unicodeInt = new ArrayList<Integer>();
        if((isLetter > 0 && isDigit > 0) || (unknown > 0)) {
            // Calculate the amount of whitespaces and commas
            // the following plaintext contains in terms of characters.
            int whitespace = 0;
            int comma = 0;
            for(int i = 0; i < plaintextCheck.length; i++) {
               if(Character.isWhitespace(plaintextCheck[i])) {
                  whitespace++;
               }
               String cipherCheckString = String.valueOf(plaintextCheck[i]);
               if(cipherCheckString.contains(",")) {
                   comma++;
               }
            }
            if(whitespace > 0 || comma > 0) {
                for(int i = 0; i < plaintextCheck.length; i++) {

                    // Skip to another i if a specific character detects a whitespace or comma
                    String cipherCheckString = String.valueOf(plaintextCheck[i]);
                    if(Character.isWhitespace(plaintextCheck[i]) || cipherCheckString.contains(",")) {
                        break;
                    }

                    ArrayList<String> cipherArrayNumber = new ArrayList<String>();
                    cipherArrayNumber.add(String.valueOf(plaintextCheck[i]));

                    String stringCipherBuilder = new String();
                    int index_skip = 0;
                    for(int l = i; l < plaintextCheck.length; l++) {
                        String SecondCipherCheckString = String.valueOf(plaintextCheck[i]);
                        stringCipherBuilder += plaintextCheck[l];
                        index_skip++;

                        if(isLetter > isDigit) {
                            int unicode = plaintextCheck[l];
                            if(unicode > m) {
                                throw new RuntimeException("ASCII value exceeds security parameter");
                            }
                            unicodeInt.add(unicode);
                        }
                    }

                    // Check if it is a digit so it can be parsed to process values
                    if(isDigit > isLetter) {
                        int unicode = Integer.parseInt(stringCipherBuilder);
                        if(unicode > m) {
                           throw new RuntimeException("Value exceeds security parameter");
                        }
                        unicodeInt.add(unicode);
                    }
                    i += index_skip;
                }
                return unicodeInt;
            }
        }
        // Check if it contains only letters, without digits, whitespaces, commas
        // or other unknown characters
        if(isLetter > 0 && isDigit == 0) {
            for(int i = 0; i < plaintextCheck.length; i++) {
               if(plaintextCheck[i] > m) {
                    System.out.println("Pick ASCII values that do not exceed the security parameter.");
                    encryption(N, e);
                    break;
               }
            }

            ArrayList unicodeChars = new ArrayList<String>();
            for(int i = 0; i < plaintext.length(); i++) {
                unicodeChars.add(plaintext.charAt(i));
            }

            for(int i = 0; i < unicodeChars.size(); i++) {
                int unicode = plaintext.charAt(i);
                unicodeInt.add(unicode);
            }
            return unicodeInt;
        }
        // Check if it contains only digits, without letters, whitespaces, commas
        // or other unknown characters
        if(isLetter == 0 && isDigit > 0) { // It's all good man
            for(int i = 0; i < plaintextCheck.length; i++) {
                unicodeInt.add(Integer.parseInt(String.valueOf(plaintextCheck[i])));
            }
            return unicodeInt;
        }
        return unicodeInt;
    }

    /**
     * Encrypts a specified plaintext
     * that will turn into ciphertext.
     *
     * @param N
     * @param e
     * @return
     */
    public static String encryption(int N, int e) {
        // * Complete
        System.out.println("Encryption:");
        System.out.println("Your message space is set {Z/NZ} = {0,1,...," + N + "}");

        Scanner input = new Scanner(System.in);
        System.out.println("Please enter a number from this set: ");
        int m = input.nextInt();

        if(m > N) {
            System.out.println("You have picked a number that is above the set.");
            System.out.println("Please enter a number from the set of " + N);
            encryption(N, e);
        }

        Scanner newInput = new Scanner(System.in);
        System.out.println("The ciphertext for your message: ");
        String cipher = newInput.nextLine();

        ArrayList<Integer> unicodeInt = extractingPlaintext(cipher, N, m, e);

        // Modular exponentiation
        System.out.println(" ");
        System.out.print("The ciphertext for your message " + cipher + " is "); // print line
        for(int i = 0; i < unicodeInt.size(); i++) {
            BigInteger plaintext, mod, result;
            BigInteger exponent = BigInteger.valueOf(e);
            plaintext = BigInteger.valueOf(unicodeInt.get(i));
            mod = BigInteger.valueOf(m);
            result = plaintext.modPow(exponent, mod);
            System.out.print(result + " ");
        }

        System.out.println(" ");
        System.out.println("----------------------");
        System.out.println(" ");

        return cipher;
    }

    /**
     * Extracts a ciphertext that was encrypted
     * that accepts integers.
     *
     * @param plaintext
     * @param N
     * @param m
     * @param e
     * @return
     */
    public static ArrayList<BigInteger> extractingCiphertext(String plaintext, int N, int m, int e) {
        char[] cipherCheck = plaintext.toCharArray();
        int isLetter = 0;
        int isDigit = 0;
        int unknown = 0;
        for(int i = 0; i < cipherCheck.length; i++){
            if(Character.isDigit(cipherCheck[i])) {
                isDigit++;
            }
            if(Character.isLetter(cipherCheck[i])) {
                isLetter++;
            }
            if(!Character.isLetterOrDigit(cipherCheck[i])) {
                unknown++;
            }
        }

        // ArrayList<Integer> unicodeInt = new ArrayList<Integer>();
        ArrayList<BigInteger> unicodeInt = new ArrayList<BigInteger>();
        if((isLetter > 0 && isDigit > 0) || (unknown > 0)) {
            int whitespace = 0;
            int comma = 0;
            for(int i = 0; i < cipherCheck.length; i++) {
                if(Character.isWhitespace(cipherCheck[i])) {
                    whitespace++;
                }
                String cipherCheckString = String.valueOf(cipherCheck[i]);
                if(cipherCheckString.contains(",")) {
                    comma++;
                }
            }
            if(whitespace > 0 || comma > 0) {
                for(int i = 0; i < cipherCheck.length; i++) {
                    String cipherCheckString = String.valueOf(cipherCheck[i]);
                    if(Character.isWhitespace(cipherCheck[i]) || cipherCheckString.contains(",")) {
                        break;
                    }

                    ArrayList<String> cipherArrayNumber = new ArrayList<String>();
                    cipherArrayNumber.add(String.valueOf(cipherCheck[i]));

                    String stringCipherBuilder = new String();
                    int index_skip = 0;
                    for(int l = i; l < cipherCheck.length; l++) {
                        String SecondCipherCheckString = String.valueOf(cipherCheck[i]);
                        if(Character.isWhitespace(cipherCheck[l]) || SecondCipherCheckString.contains(",")) {
                            break;
                        }
                        stringCipherBuilder += cipherCheck[l];
                        index_skip++;
                    }

                    BigInteger stringCipherBigInteger = new BigInteger(stringCipherBuilder);

                    if(stringCipherBigInteger.intValue() > m) {
                        System.out.println(" ");
                        System.out.println("Pick another ASCII value that does not exceed the value of the security parameter.");
                        System.out.println(" ");
                        encryption(N, e);
                        break;
                    }

                    unicodeInt.add(stringCipherBigInteger);
                    i += index_skip;
                }

                return unicodeInt;
            }
        }
        if(isLetter > 0 && isDigit == 0) {
            for(int i = 0; i < cipherCheck.length; i++) {
                if(cipherCheck[i] > m) {
                    System.out.println("Pick ASCII values that do not exceed the security parameter.");
                    encryption(N, e);
                    break;
                }
            }

            ArrayList unicodeChars = new ArrayList<String>();
            for(int i = 0; i < plaintext.length(); i++) {
                unicodeChars.add(plaintext.charAt(i));
            }

            for(int i = 0; i < unicodeChars.size(); i++) {
                int unicode = plaintext.charAt(i);
                unicodeInt.add(BigInteger.valueOf(unicode));
            }

            return unicodeInt;
        }

        return unicodeInt;
    }

    /**
     * Decrypts a specified ciphertext
     * that will decrypt into message bits
     * that retrieves randomized values
     * from an encrypted text.
     *
     * @param N
     * @param e
     * @param d
     * @return
     */
    public static String decryption(int N, int e, int d) {
        System.out.println("Decryption:");
        System.out.println("Your message space is set {Z/NZ} = {0,1,...," + N + "}");

        Scanner input = new Scanner(System.in);
        System.out.println("Please enter a number from this set: ");
        int m = input.nextInt();

        if(m > N) {
            System.out.println("You have picked a number that is above the set.");
            System.out.println("Please enter a number from the set of " + N);
            decryption(N, e, d);
        }

        Scanner newInput = new Scanner(System.in);
        System.out.println("The plaintext for your message: ");
        String plaintextInput = newInput.nextLine();

        ArrayList<BigInteger> unicodeInt = extractingCiphertext(plaintextInput, N, m, e);

        System.out.println(" ");
        System.out.print("The plaintext for your ciphertext " + plaintextInput + " is "); // print line
        for(int i = 0; i < unicodeInt.size(); i++) {
            BigInteger plaintext, mod, result;
            BigInteger exponent = BigInteger.valueOf(d);
            plaintext = unicodeInt.get(i);
            mod = BigInteger.valueOf(m);
            result = plaintext.modPow(exponent, mod);
            System.out.print(result + " ");
        }

        System.out.println(" ");
        System.out.println("----------------------");
        System.out.println(" ");

        return plaintextInput;
    }
}
